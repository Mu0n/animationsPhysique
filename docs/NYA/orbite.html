<div class="imageContainer aspectRation2-1"><div id="orbite"></div></div>

<div class="controls">
  <label for="masseCentre">Masse de l'objet central:&nbsp;<input type="range" id="masseCentre" name="masseCentre" value="30" max="40" min="24" step="0.2" oninput="redraw()" onchange="redraw()"></label>
  <button type="button" onclick="redraw()">Click Me!</button>
  <label for="vitesseTangentielle">Vitesse Tangentielle:&nbsp;<input type="checkbox" class="switch" id="vitesseTangentielle" name="vitesseTangentielle"></label><br>
  <label for="trace">Trace d'orbite:&nbsp;<input type="checkbox" class="switch" id="trace" name="trace"></label><br>
  </div>
</div>

<script src='utils/includes/vector.js'></script>
<script>
  //Paramètres fudge-factor pour aider à créer une animation satisfaisante
  var constanteG = 1000;
  var maxTracesOrbite = 4;
  var tracesOrbite = [];
  var delayEnMs = 22;
  var signet = 0;
  
  
  //Paramètres de la masse centrale; positions en coordonnées absolues
  var solX = 500;
  var solY = 250;

  class Cinema{
        constructor(x, y, vX, vY){
        this.x = x;
        this.y = y;
        this.vX = vX;
        this.vY = vY;
        this.aX = 0.0;
        this.aY = 0.0;
        }
  }

  //Classe contentant toutes les données de cinématique
  var cin = new Cinema(800.0, 250.0, 0.0, 9.0);
  
  //Création de l'élément svg (l'image).
  var draw = SVG('orbite').viewbox({ x: 0, y: 0, width: 1000, height: 500 });
  
  //Création des différents éléments de l'image
  var masseCentre = draw.circle(1).attr({ cx: solX, cy: solY, fill: '#ffffff' });

  //Création de plusieurs Satellites en avance pour la fonctionalité de trace
  //for(i=0; i < maxTracesOrbite; i++){
  //  var masseSat = draw.circle(15).attr({ cx: posX, cy: posY, fill: '#ffffff' });
  //  tracesOrbite.push(masseSat);
  //}

    var masseSat = draw.circle(15).attr({ cx: cin.x, cy: cin.y, fill: '#ffffff' });

	//Redessine l'image en tenant compte des contrôles externes
    var partLeBal = setInterval(redraw,delayEnMs);
   // var vitTan = draw.line(cin.posX, cin.posY, 10, 15).stroke({width: 1}).vector({size:4});


  function itereCinematique(cinema){
    var ret = cinema;

    //Définit et récupère les valeurs nécessaires à l'image.
    var rC = parseFloat(document.getElementById("masseCentre").value);
	//Ajuste les rayons de la source et de l'objet et la position de l'objet.
    masseCentre.radius(rC);
    var locX = localX(ret.x);
	var locY = localY(ret.y);

    var distAuCarre = locX*locX + locY*locY;
	var dist = Math.sqrt(distAuCarre);
    var acc = constanteG * rC * 1.0 / distAuCarre;

	ret.aX = -(locX / dist) * acc;
	ret.aY = -(locY / dist) * acc;

	//Algorithme Euler, la vitesse est modifiée avant la position
	ret.vX += ret.aX;
	ret.vY += ret.aY;
	locX += ret.vX;
	locY += ret.vY;

	//Rafraichit les positions en coordonnées globales et redessine le satellite
	ret.x = globalX(locX);
	ret.y = globalX(locY);

	return ret;
  }

  function redraw() {
    cin = itereCinematique(cin);
	masseSat.cx(cin.x).cy(cin.y);
	//vitTan.plot(cin.x, cin.y, cin.x + 5*cin.vX, cin.y - 5*cin.vY);
	if(document.getElementById('vitesseTangentielle').checked) {
		//vitTan.show();
	} else{
		//vitTan.hide();
	}

  }
  
  function localX(globalX){
		var retVal = globalX - solX;
		return retVal;
  }
  
  function  localY(globalY){
		var retVal = solY - globalY;
		return retVal;
  }
  
  function globalX(localX){
		var retVal = localX + solX;
		return retVal;
  }
  
  function globalY(localY){
		var retVal = solY - localY;
		return retVal;
  }



</script>
